import { Groq } from 'groq-sdk';
import * as fs from 'fs';
import * as path from 'path';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config();

/**
 * Interface for vision analysis results
 */
export interface VisionAnalysisResult {
  success: boolean;
  analysis?: string;
  error?: string;
  model: string;
  imagePath: string;
  timestamp: Date;
}

/**
 * Interface for analysis options
 */
export interface AnalysisOptions {
  prompt?: string;
  model?: string;
  maxTokens?: number;
  temperature?: number;
}

/**
 * Groq Vision Analyzer for analyzing PNG images generated by the quaternion attractor
 */
export class GroqVisionAnalyzer {
  private client: Groq;
  private defaultModel: string;

  constructor() {
    const apiKey = process.env.GROQ_API_KEY;
    if (!apiKey) {
      throw new Error('GROQ_API_KEY environment variable is required');
    }

    this.client = new Groq({
      apiKey: apiKey,
    });

    this.defaultModel = process.env.GROQ_VISION_MODEL || 'meta-llama/llama-4-scout-17b-16e-instruct';
  }

  /**
   * Analyze a PNG image using Groq's vision API
   */
  async analyzeImage(
    imagePath: string,
    options: AnalysisOptions = {}
  ): Promise<VisionAnalysisResult> {
    try {
      // Validate image file exists
      if (!fs.existsSync(imagePath)) {
        throw new Error(`Image file not found: ${imagePath}`);
      }

      // Read and encode image to base64
      const imageBuffer = fs.readFileSync(imagePath);
      const imageBase64 = imageBuffer.toString('base64');

      // Default prompt for quaternion attractor analysis
      const defaultPrompt = `Analyze this mathematical visualization image. This appears to be a quaternion attractor pattern generated from 4D quaternion dynamics projected to 2D. Please describe:
1. The overall visual pattern and structure
2. Any symmetries or geometric features you observe
3. The color distribution and intensity patterns
4. Any mathematical or fractal-like properties
5. The complexity and density of the pattern
6. Any interesting visual characteristics that might relate to the underlying mathematical system

Be specific about the visual elements and provide insights that could be useful for understanding the mathematical properties of this attractor.`;

      const prompt = options.prompt || defaultPrompt;
      const model = options.model || this.defaultModel;

      // Create the request
      const response = await this.client.chat.completions.create({
        model: model,
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: prompt,
              },
              {
                type: 'image_url' as const,
                image_url: {
                  url: `data:image/png;base64,${imageBase64}`,
                },
              },
            ],
          },
        ],
        max_tokens: options.maxTokens || 1000,
        temperature: options.temperature || 0.7,
      });

      return {
        success: true,
        analysis: response.choices[0]?.message?.content || 'No analysis returned',
        model: model,
        imagePath: imagePath,
        timestamp: new Date(),
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        model: options.model || this.defaultModel,
        imagePath: imagePath,
        timestamp: new Date(),
      };
    }
  }

  /**
   * Analyze multiple PNG images in a directory
   */
  async analyzeDirectory(
    directoryPath: string,
    options: AnalysisOptions = {}
  ): Promise<VisionAnalysisResult[]> {
    try {
      const files = fs.readdirSync(directoryPath);
      const pngFiles = files.filter(file => file.toLowerCase().endsWith('.png'));

      if (pngFiles.length === 0) {
        throw new Error(`No PNG files found in directory: ${directoryPath}`);
      }

      const results: VisionAnalysisResult[] = [];
      
      for (const file of pngFiles) {
        const fullPath = path.join(directoryPath, file);
        console.log(`Analyzing: ${file}`);
        
        const result = await this.analyzeImage(fullPath, options);
        results.push(result);
        
        // Add a small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      return results;
    } catch (error) {
      throw new Error(`Failed to analyze directory: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Compare multiple images and provide comparative analysis
   */
  async compareImages(
    imagePaths: string[],
    options: AnalysisOptions = {}
  ): Promise<VisionAnalysisResult> {
    try {
      if (imagePaths.length < 2) {
        throw new Error('At least 2 images required for comparison');
      }

      // Read and encode all images
      const imageContents = imagePaths.map(imagePath => {
        if (!fs.existsSync(imagePath)) {
          throw new Error(`Image file not found: ${imagePath}`);
        }
        const imageBuffer = fs.readFileSync(imagePath);
        const imageBase64 = imageBuffer.toString('base64');
        return {
          type: 'image_url' as const,
          image_url: {
            url: `data:image/png;base64,${imageBase64}`,
          },
        };
      });

      const defaultPrompt = `Compare these quaternion attractor visualizations. These are mathematical patterns generated from 4D quaternion dynamics. Please analyze:

1. Similarities and differences between the patterns
2. How the mathematical parameters might differ between them
3. Which pattern appears more complex or interesting
4. Any evolutionary or progressive changes you observe
5. The relationship between the different visual structures
6. Recommendations for which parameters might produce the most interesting results

Provide a detailed comparative analysis that could help optimize the mathematical parameters for generating more interesting attractor patterns.`;

      const prompt = options.prompt || defaultPrompt;
      const model = options.model || this.defaultModel;

      // Create the request with multiple images
      const response = await this.client.chat.completions.create({
        model: model,
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: prompt,
              },
              ...imageContents,
            ],
          },
        ],
        max_tokens: options.maxTokens || 1500,
        temperature: options.temperature || 0.7,
      });

      return {
        success: true,
        analysis: response.choices[0]?.message?.content || 'No analysis returned',
        model: model,
        imagePath: imagePaths.join(', '),
        timestamp: new Date(),
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        model: options.model || this.defaultModel,
        imagePath: imagePaths.join(', '),
        timestamp: new Date(),
      };
    }
  }

  /**
   * Save analysis results to a JSON file
   */
  async saveAnalysisResults(
    results: VisionAnalysisResult | VisionAnalysisResult[],
    outputPath: string
  ): Promise<void> {
    try {
      const data = {
        timestamp: new Date().toISOString(),
        results: Array.isArray(results) ? results : [results],
        summary: {
          totalImages: Array.isArray(results) ? results.length : 1,
          successfulAnalyses: Array.isArray(results) 
            ? results.filter(r => r.success).length 
            : (results.success ? 1 : 0),
          failedAnalyses: Array.isArray(results) 
            ? results.filter(r => !r.success).length 
            : (results.success ? 0 : 1),
        },
      };

      fs.writeFileSync(outputPath, JSON.stringify(data, null, 2));
      console.log(`Analysis results saved to: ${outputPath}`);
    } catch (error) {
      throw new Error(`Failed to save analysis results: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}
