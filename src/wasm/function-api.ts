/**
 * Function-based API for WASM Attractor Engine
 * 
 * Since WASM cannot export classes, this provides a function-based interface
 * that can be called from JavaScript. Uses memory pointers to manage state.
 */

import { AttractorEngine, AttractorConfig, SideFlipVariation } from './attractor-engine';
import { DeterministicRandom } from './deterministic-random';

// Global storage for engine instances (using simple array for now)
// In a real implementation, this would use proper memory management
let engines: AttractorEngine[] = [];
let nextEngineId: i32 = 0;

/**
 * Create a new attractor engine instance
 * Returns an engine ID that can be used for subsequent operations
 */
export function createAttractorEngine(
  maxPoints: i32,
  seed: i32,
  stepVectorX: f32,
  stepVectorY: f32,
  stepVectorZ: f32,
  initialX: f32,
  initialY: f32,
  initialZ: f32,
  sideFlipVariation: i32,
  globalRotationW: f32,
  globalRotationX: f32,
  globalRotationY: f32,
  globalRotationZ: f32
): i32 {
  // Create step vector
  const stepVector = new Float32Array(3);
  stepVector[0] = stepVectorX;
  stepVector[1] = stepVectorY;
  stepVector[2] = stepVectorZ;
  
  // Create initial position
  const initialPosition = new Float32Array(3);
  initialPosition[0] = initialX;
  initialPosition[1] = initialY;
  initialPosition[2] = initialZ;
  
  // Create global rotation quaternion
  const globalRotation = new Float32Array(4);
  globalRotation[0] = globalRotationW;
  globalRotation[1] = globalRotationX;
  globalRotation[2] = globalRotationY;
  globalRotation[3] = globalRotationZ;
  
  // Create configuration
  const config = new AttractorConfig(
    seed,
    stepVector,
    initialPosition,
    sideFlipVariation,
    globalRotation
  );
  
  // Create engine instance
  const engine = new AttractorEngine(maxPoints, config);
  const engineId = nextEngineId++;
  engines.push(engine);
  
  return engineId;
}

/**
 * Generate points for a specific engine
 */
export function generatePoints(engineId: i32, count: i32): void {
  if (engineId >= 0 && engineId < engines.length) {
    engines[engineId].generatePoints(count);
  }
}

/**
 * Get the number of points generated by an engine
 */
export function getPointCount(engineId: i32): i32 {
  if (engineId >= 0 && engineId < engines.length) {
    return engines[engineId].getPointCount();
  }
  return 0;
}

/**
 * Get a range of points from an engine
 * Returns a pointer to the points array (JavaScript will need to read from memory)
 */
export function getPointRange(engineId: i32, start: i32, count: i32): Float32Array {
  if (engineId >= 0 && engineId < engines.length) {
    return engines[engineId].getPointRange(start, count);
  }
  return new Float32Array(0);
}

/**
 * Get all points from an engine
 */
export function getAllPoints(engineId: i32): Float32Array {
  if (engineId >= 0 && engineId < engines.length) {
    return engines[engineId].getPoints();
  }
  return new Float32Array(0);
}

/**
 * Get statistics from an engine
 */
export function getStatistics(engineId: i32): Float32Array {
  if (engineId >= 0 && engineId < engines.length) {
    return engines[engineId].getStatistics();
  }
  return new Float32Array(0);
}

/**
 * Get current state from an engine
 */
export function getCurrentState(engineId: i32): Float32Array {
  if (engineId >= 0 && engineId < engines.length) {
    const state = engines[engineId].getCurrentState();
    const result = new Float32Array(4);
    result[0] = state.x;
    result[1] = state.y;
    result[2] = state.z;
    result[3] = f32(state.side);
    return result;
  }
  return new Float32Array(0);
}

/**
 * Update configuration for an engine
 */
export function updateConfig(
  engineId: i32,
  seed: i32,
  stepVectorX: f32,
  stepVectorY: f32,
  stepVectorZ: f32,
  initialX: f32,
  initialY: f32,
  initialZ: f32,
  sideFlipVariation: i32,
  globalRotationW: f32,
  globalRotationX: f32,
  globalRotationY: f32,
  globalRotationZ: f32
): void {
  if (engineId >= 0 && engineId < engines.length) {
    // Create new configuration
    const stepVector = new Float32Array(3);
    stepVector[0] = stepVectorX;
    stepVector[1] = stepVectorY;
    stepVector[2] = stepVectorZ;
    
    const initialPosition = new Float32Array(3);
    initialPosition[0] = initialX;
    initialPosition[1] = initialY;
    initialPosition[2] = initialZ;
    
    const globalRotation = new Float32Array(4);
    globalRotation[0] = globalRotationW;
    globalRotation[1] = globalRotationX;
    globalRotation[2] = globalRotationY;
    globalRotation[3] = globalRotationZ;
    
    const config = new AttractorConfig(
      seed,
      stepVector,
      initialPosition,
      sideFlipVariation,
      globalRotation
    );
    
    engines[engineId].updateConfig(config);
  }
}

/**
 * Reset an engine to its initial state
 */
export function resetEngine(engineId: i32): void {
  if (engineId >= 0 && engineId < engines.length) {
    engines[engineId].reset();
  }
}

/**
 * Get the number of active engines
 */
export function getEngineCount(): i32 {
  return engines.length;
}

/**
 * Clear all engines (for cleanup)
 */
export function clearAllEngines(): void {
  engines = [];
  nextEngineId = 0;
}

// Export the enum values as constants
export const SIDE_FLIP_PLAIN = SideFlipVariation.PLAIN_FLIP;
export const SIDE_FLIP_SMALLEST = SideFlipVariation.FLIP_SMALLEST;
export const SIDE_FLIP_ALL_EXCEPT_LARGEST = SideFlipVariation.FLIP_ALL_EXCEPT_LARGEST;
