#!/usr/bin/env node

/**
 * Random PNG Generator for Quaternion Attractor
 * 
 * This tool takes the random parameter data generated by the random-parameter-generator
 * and creates actual PNG images using the new logarithmic normalization fix.
 * 
 * This allows us to:
 * 1. Visualize the random parameter combinations
 * 2. Test the robustness of our normalization fix
 * 3. Discover new and interesting mathematical patterns
 * 4. Create a diverse collection of attractor images
 */

const path = require('path');
const fs = require('fs');

// Import the attractor engine and image renderer
const { JavaScriptAttractorEngine } = require('../dist/typescript/core/js-engine');
const { createQuaternion, createVector3D, SideFlipMode, ProjectionType } = require('../dist/typescript/core/attractor-engine');
const { SimplePNGRenderer } = require('../dist/typescript/node/image-renderer');

class RandomPNGGenerator {
  constructor() {
    this.engine = new JavaScriptAttractorEngine();
    this.generatedImages = [];
  }

  /**
   * Convert parameter data to engine format
   */
  convertParameters(parameterData) {
    const constants = {
      start: createQuaternion(
        parameterData.start.w,
        parameterData.start.x,
        parameterData.start.y,
        parameterData.start.z
      ),
      wind: createQuaternion(
        parameterData.wind.w,
        parameterData.wind.x,
        parameterData.wind.y,
        parameterData.wind.z
      ),
      additive: createVector3D(
        parameterData.additive.x,
        parameterData.additive.y,
        parameterData.additive.z
      ),
      mode: parameterData.mode // Mode belongs in constants, not renderParams
    };

    const renderParams = {
      batchSize: parameterData.batchSize,
      projectionType: parameterData.projectionType === 'simple' ? ProjectionType.SIMPLE : ProjectionType.SPHERE,
      cameraRotation: createQuaternion(
        parameterData.cameraRotation.w,
        parameterData.cameraRotation.x,
        parameterData.cameraRotation.y,
        parameterData.cameraRotation.z
      )
    };

    return { constants, renderParams };
  }

  /**
   * Generate PNG from random parameter data
   */
  async generatePNGFromParameters(parameterData, outputDir, index) {
    console.log(`\n🎨 Generating PNG from random parameters ${index}...`);
    
    try {
      // Convert parameters
      const { constants, renderParams } = this.convertParameters(parameterData);
      
      // Generate attractor points
      console.log(`🎯 Generating ${renderParams.batchSize} points...`);
      const result = this.engine.generateBatch(constants, renderParams);
      
      console.log(`✅ Generated ${result.points.length} points`);
      console.log(`🎯 Final quaternion: (${result.finalQuaternion.w.toFixed(3)}, ${result.finalQuaternion.x.toFixed(3)}, ${result.finalQuaternion.y.toFixed(3)}, ${result.finalQuaternion.z.toFixed(3)})`);
      
      // Create image renderer with proper coordinate scaling
      // Scale factor should be proportional to image size for proper coordinate mapping
      const baseScale = 150.0; // Original scale for 800x600
      const baseSize = 800; // Original width
      const scaleFactor = parameterData.imageSize.width / baseSize;
      const scale = baseScale * scaleFactor;
      
      const imageConfig = {
        width: parameterData.imageSize.width,
        height: parameterData.imageSize.height,
        scale: scale, // Proportional scaling based on image size
        offsetX: parameterData.imageSize.width / 2, // Center X
        offsetY: parameterData.imageSize.height / 2, // Center Y
        blurRadius: 1.5, // Same as original PNG generator
        normalizationMode: 'logarithmic' // Use our new fix!
      };
      
      // Create descriptive filename
      const modeName = this.getModeName(parameterData.mode).toLowerCase().replace(/\s+/g, '_');
      const projectionName = parameterData.projectionType.toLowerCase();
      const batchSize = parameterData.batchSize;
      const filename = `random_${index.toString().padStart(3, '0')}_${modeName}_${projectionName}_${batchSize}pts.png`;
      
      // Create full path for the PNG file
      const imagePath = path.join(outputDir, filename);
      
      const renderer = new SimplePNGRenderer(imageConfig);
      
      // Render the image (this will write the file directly)
      console.log(`🖼️  Rendering to PNG...`);
      const renderResult = await renderer.renderPointsToPNG(result.points, imagePath);
      
      console.log(`💾 PNG saved: ${filename}`);
      console.log(`📊 Statistics: min(${renderResult.statistics.min.r.toFixed(1)}, ${renderResult.statistics.min.g.toFixed(1)}, ${renderResult.statistics.min.b.toFixed(1)}) max(${renderResult.statistics.max.r.toFixed(1)}, ${renderResult.statistics.max.g.toFixed(1)}, ${renderResult.statistics.max.b.toFixed(1)})`);
      
      return {
        index,
        filename,
        imagePath,
        parameters: parameterData,
        result: renderResult,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      console.error(`❌ Error generating PNG ${index}:`, error.message);
      return null;
    }
  }

  /**
   * Get mode name for display
   */
  getModeName(mode) {
    switch (mode) {
      case SideFlipMode.PLAIN_FLIP: return 'Plain Flip';
      case SideFlipMode.FLIP_SMALLEST: return 'Flip Smallest';
      case SideFlipMode.FLIP_ALL_EXCEPT_LARGEST: return 'Flip All Except Largest';
      default: return 'Unknown';
    }
  }

  /**
   * Generate PNGs from random parameter collection
   */
  async generatePNGCollection(parameterCollectionPath) {
    console.log(`🎨 Random PNG Generator`);
    console.log(`=======================`);
    console.log(`Loading parameter collection from: ${parameterCollectionPath}`);
    
    // Load parameter collection
    const collectionData = JSON.parse(fs.readFileSync(parameterCollectionPath, 'utf8'));
    console.log(`📊 Found ${collectionData.images.length} parameter sets`);
    
    // Create output directory
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const outputDir = path.join(__dirname, '..', 'output', 'random_pngs', timestamp);
    
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    console.log(`📁 Output directory: ${outputDir}`);
    
    // Generate PNGs for each parameter set
    for (const imageData of collectionData.images) {
      const pngResult = await this.generatePNGFromParameters(
        imageData.parameters,
        outputDir,
        imageData.index
      );
      
      if (pngResult) {
        this.generatedImages.push(pngResult);
      }
    }
    
    // Save generation summary
    await this.saveGenerationSummary(outputDir, collectionData);
    
    console.log(`\n🎉 Random PNG generation complete!`);
    console.log(`📊 Generated ${this.generatedImages.length} PNG images`);
    console.log(`📁 All images saved to: ${outputDir}`);
    
    return outputDir;
  }

  /**
   * Save generation summary
   */
  async saveGenerationSummary(outputDir, originalCollection) {
    const summary = {
      timestamp: new Date().toISOString(),
      tool: 'Random PNG Generator',
      originalCollection: originalCollection.timestamp,
      totalImages: this.generatedImages.length,
      images: this.generatedImages,
      statistics: this.calculateGenerationStatistics()
    };
    
    const summaryPath = path.join(outputDir, 'png_generation_summary.json');
    fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));
    
    console.log(`📋 Generation summary saved to: ${summaryPath}`);
  }

  /**
   * Calculate generation statistics
   */
  calculateGenerationStatistics() {
    const stats = {
      modeDistribution: {},
      projectionDistribution: {},
      batchSizeRange: { min: Infinity, max: -Infinity },
      imageSizeRange: { width: { min: Infinity, max: -Infinity }, height: { min: Infinity, max: -Infinity } },
      pointCountRange: { min: Infinity, max: -Infinity },
      renderTimeRange: { min: Infinity, max: -Infinity }
    };
    
    this.generatedImages.forEach(image => {
      // Mode distribution
      const modeName = this.getModeName(image.parameters.mode);
      stats.modeDistribution[modeName] = (stats.modeDistribution[modeName] || 0) + 1;
      
      // Projection distribution
      const projectionName = image.parameters.projectionType;
      stats.projectionDistribution[projectionName] = (stats.projectionDistribution[projectionName] || 0) + 1;
      
      // Batch size range
      stats.batchSizeRange.min = Math.min(stats.batchSizeRange.min, image.parameters.batchSize);
      stats.batchSizeRange.max = Math.max(stats.batchSizeRange.max, image.parameters.batchSize);
      
      // Image size range
      stats.imageSizeRange.width.min = Math.min(stats.imageSizeRange.width.min, image.parameters.imageSize.width);
      stats.imageSizeRange.width.max = Math.max(stats.imageSizeRange.width.max, image.parameters.imageSize.width);
      stats.imageSizeRange.height.min = Math.min(stats.imageSizeRange.height.min, image.parameters.imageSize.height);
      stats.imageSizeRange.height.max = Math.max(stats.imageSizeRange.height.max, image.parameters.imageSize.height);
      
      // Point count range
      stats.pointCountRange.min = Math.min(stats.pointCountRange.min, image.result.pointCount);
      stats.pointCountRange.max = Math.max(stats.pointCountRange.max, image.result.pointCount);
      
      // Render time range
      stats.renderTimeRange.min = Math.min(stats.renderTimeRange.min, image.result.renderTime);
      stats.renderTimeRange.max = Math.max(stats.renderTimeRange.max, image.result.renderTime);
    });
    
    return stats;
  }

  /**
   * Analyze generated images
   */
  analyzeGeneratedImages() {
    console.log(`\n📊 Generated Image Analysis`);
    console.log(`=============================`);
    
    const stats = this.calculateGenerationStatistics();
    
    console.log(`🎯 Mode Distribution:`);
    Object.entries(stats.modeDistribution).forEach(([mode, count]) => {
      console.log(`  ${mode}: ${count} images`);
    });
    
    console.log(`\n📐 Projection Distribution:`);
    Object.entries(stats.projectionDistribution).forEach(([projection, count]) => {
      console.log(`  ${projection}: ${count} images`);
    });
    
    console.log(`\n📏 Batch Size Range: ${stats.batchSizeRange.min} - ${stats.batchSizeRange.max} points`);
    console.log(`🖼️  Image Size Range: ${stats.imageSizeRange.width.min}x${stats.imageSizeRange.height.min} - ${stats.imageSizeRange.width.max}x${stats.imageSizeRange.height.max}`);
    console.log(`🎯 Point Count Range: ${stats.pointCountRange.min} - ${stats.pointCountRange.max} points`);
    console.log(`⏱️  Render Time Range: ${stats.renderTimeRange.min.toFixed(0)} - ${stats.renderTimeRange.max.toFixed(0)}ms`);
  }
}

/**
 * Main execution
 */
async function main() {
  // Find the most recent parameter collection
  const randomParamsDir = path.join(__dirname, '..', 'output', 'random_parameters');
  const collections = fs.readdirSync(randomParamsDir).filter(dir => 
    fs.statSync(path.join(randomParamsDir, dir)).isDirectory()
  ).sort().reverse(); // Most recent first
  
  if (collections.length === 0) {
    console.error('❌ No random parameter collections found. Run random-parameter-generator.js first.');
    return;
  }
  
  const latestCollection = collections[0];
  const collectionPath = path.join(randomParamsDir, latestCollection, 'collection_summary.json');
  
  console.log(`📁 Using latest parameter collection: ${latestCollection}`);
  
  const generator = new RandomPNGGenerator();
  
  // Generate PNG collection
  const outputDir = await generator.generatePNGCollection(collectionPath);
  
  // Analyze results
  generator.analyzeGeneratedImages();
  
  console.log(`\n🎯 NEXT STEPS`);
  console.log(`=============`);
  console.log(`1. Review the generated PNG images in: ${outputDir}`);
  console.log(`2. Use Groq Vision to analyze interesting patterns`);
  console.log(`3. Compare with previous images to test normalization consistency`);
  console.log(`4. Document any new or interesting mathematical behaviors`);
  console.log(`5. Create a gallery of the most interesting random patterns`);
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { RandomPNGGenerator };
